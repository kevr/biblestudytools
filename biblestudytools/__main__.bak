"""
https://biblestudytools.com/nkjv New King James Version Bible scraper.

This script scrapes bible chapters from biblestudytools.com
and stores them in $HOME/.biblestudytools for subsequent
references.

Author: kevr
"""
import os
import sys
import argparse
import curses
import atexit
import logging
import logging.config
import traceback
from .bible import Bible
from .getch import getch
from .book import Chapter
from .conf import PROG
from .http import HttpError

SOURCE = "https://biblestudytools.com"
HOME = os.environ.get("HOME")

logging.basicConfig(filename="/tmp/bst.log", level=logging.DEBUG,
                    format='%(asctime)s %(levelname)s:%(message)s')


def parse_args():
    parser = argparse.ArgumentParser(prog=PROG,
                                     description=f"Cache client for {SOURCE}")

    parser.add_argument("-t", "--translation", default="nkjv")
    parser.add_argument("book")
    parser.add_argument("verse")

    args = parser.parse_args()

    ch = 0  # Chapter
    verse = None  # Verse
    if ':' in args.verse:
        ch, verse = args.verse.split(':')
        ch = int(ch)
        if '-' in verse:
            verse = verse.split('-')
            try:
                start, end = [int(x) for x in verse]
            except Exception:
                raise argparse.ArgumentError(
                    f"invalid verse specification '{args.verse}'")

            if start < 1 or start > end:
                raise argparse.ArgumentError(
                    "invalid verse range; a >= 1 && b >= a")

            verse = (start, end)
        else:
            verse = int(verse)
            verse = (verse, verse)
    else:
        ch = int(args.verse)

    return {
        "translation": args.translation,
        "book": args.book,
        "chapter": ch,
        "verse": verse,
    }


def parse_range(verses: str) -> tuple[int, int]:
    if '-' not in verses:
        i = int(verses)
        return (i, i)

    start, end = verses.split('-')
    return (
        int(start),
        int(end),
    )


def wait_for_input(chapter: int) -> int:
    """
    print("Press ", end='')
    if chapter > 1:
        print("'w' for previous, ", end='')
    print("'e' for next, or 'q' to exit... ", end='')
    sys.stdout.flush()
    """
    char = getch()
    if char == 'q':
        sys.exit(0)
    elif chapter > 1 and char == 'w':
        chapter -= 1
    elif char == 'e':
        chapter += 1
    return chapter


def output_chapter(chapter: Chapter, verses: tuple[int, int]):
    start, end = verses
    print(f"\n <---> {chapter.title}:{start}-{end} <--->\n")
    for i in range(start - 1, end):
        for line in chapter.verses[i]:
            print(line)
        # print(chapter.verses[i])
    print()


def single_view(bible: Bible, book: str, ch: int, verses: tuple[int, int]):
    content = bible.get_chapter(book, ch)
    chapter = Chapter(content)

    if not verses:
        verses = chapter.range()

    output_chapter(chapter, verses)


def get_lines(chapter: Chapter):
    lines = []
    for vl in chapter.verses:
        for v in vl:
            lines.append(v)
    return lines


BLUE_BG = 1


def book_view(bible: Bible, book: str, ch: int, verses: tuple[int, int]):
    stdscr = curses.initscr()
    curses.noecho()
    curses.curs_set(0)
    curses.start_color()
    curses.init_pair(BLUE_BG, curses.COLOR_BLACK, curses.COLOR_BLUE)
    stdscr.keypad(True)

    atexit.register(curses.endwin)

    stdscr.refresh()

    w = curses.COLS

    win_offset = 1

    titlebar = stdscr.derwin(win_offset, w, 0, 0)
    titlebar.bkgd(' ', curses.color_pair(BLUE_BG) | curses.A_BOLD)
    titlebar.refresh()
    pad = stdscr.subpad(curses.LINES - win_offset, w, win_offset, 0)
    pad.scrollok(1)

    rz = 0
    while True:
        pad.erase()
        try:
            content = bible.get_chapter(book, ch)
            chapter = Chapter(content)
        except HttpError as e:
            print(e)
            return None

        verses = chapter.range()

        # Rerender titlebar
        title = f"{chapter.title} | {verses[0]}-{verses[1]}"
        titlebar.erase()
        lt = len(title)
        x = int(curses.COLS / 2) - int(lt / 2) - int(not (lt % 2))
        titlebar.addstr(0, x, title)
        titlebar.refresh()

        # Pad update
        lines = get_lines(chapter)
        n = min(curses.LINES - 1, len(lines))
        pos = 0
        for i in range(pos, n):
            pad.addstr(i, 0, lines[i])
        pad.refresh()

        while True:
            h_ = curses.LINES - 1
            logging.info(f"pos: {pos}")
            char = stdscr.getch()
            if char == curses.KEY_UP and pos > 0:
                logging.info("KEY_UP triggered")
                pad.scroll(-1)
                pos -= 1
                pad.addstr(0, 0, lines[pos])
            elif char == curses.KEY_DOWN and pos < (len(lines) - h_):
                logging.info("KEY_DOWN triggered")
                pad.scroll(1)
                pos += 1
                i = curses.LINES - 1
                logging.info(f"i={i}")
                pad.addstr(i - 1, 0, lines[pos + i - 1])
            elif char == curses.KEY_RIGHT and ch < len(chapter.verses) - 1:
                ch += 1
                break
            elif char == curses.KEY_LEFT and ch > 1:
                ch -= 1
                break
            elif char == curses.KEY_RESIZE:
                # rz % 2 == 0 -> skip, this was caused by resizeterm
                # rz % 2 == 1 -> resize terminal
                rz += 1
                if rz % 2 == 0:
                    rz = 0
                    break
                logging.info("Caught RESIZE...")
                pad.deleteln()
                titlebar.deleteln()
                y, x = stdscr.getmaxyx()
                curses.resizeterm(y, x)
                stdscr.clear()
                stdscr.refresh()

                titlebar = stdscr.derwin(1, curses.COLS, 0, 0)
                titlebar.bkgd(' ', curses.color_pair(BLUE_BG) | curses.A_BOLD)
                titlebar.refresh()
                pad = stdscr.subpad(
                    curses.LINES - 1, curses.COLS, 1, 0)
                pad.scrollok(1)
                break
            elif char == ord('q'):
                logging.info("'q' pressed, quitting")
                sys.exit(0)

            pad.refresh()


def main():
    try:
        args = parse_args()
    except argparse.ArgumentError as exc:
        print(exc)
        return 1

    bible = Bible(args.get("translation"))
    book = args.get("book")
    ch = args.get("chapter")
    verses = args.get("verse")

    is_oneshot = verses is not None
    f = {
        True: single_view,
        False: book_view,
    }

    try:
        f.get(is_oneshot)(bible, book, ch, verses)
    except Exception as exc:
        logging.error(exc)
        logging.error(traceback.format_exc())

    return 0


if __name__ == "__main__":
    e = 1
    try:
        e = main()
    except Exception as exc:
        print(exc)
        e = 1
    sys.exit(1)
